/**
 * KV Type Configuration System
 *
 * Defines indexing rules for each "table" type in the KV datastore.
 *
 * Design Philosophy:
 * - Types are schema-less (any fields allowed), but indexing is explicit
 * - Each indexed field creates additional KV writes, so index sparingly
 * - Type configs are immutable at runtime (require redeploy to change)
 *
 * Performance Note:
 * - Each indexed field adds ~1-3 KV writes per create/update
 * - Each time field adds 2 KV writes (ascending + descending)
 * - Each search field adds N KV writes (N = unique tokens in field)
 */

/**
 * Configuration for a KV type (table)
 *
 * Think of this as a "CREATE TABLE" statement with INDEX specifications.
 * Unlike SQL, we don't define the full schema - only which fields to index.
 */
export interface TypeConfig {
  /**
   * Fields to create equality indexes for (WHERE field=value)
   *
   * Use for: Status flags, categories, foreign keys, enums
   * Don't use for: Unique IDs (use record ID instead), free text, large strings
   *
   * Performance: 1 KV write per field on create, 1-2 on update (if changed)
   */
  indexedFields: string[];

  /**
   * Time fields for sorting/pagination (createdAt, updatedAt, etc.)
   *
   * Use for: Timestamps that you'll sort by (most recent, oldest, etc.)
   * Don't use for: Arbitrary dates you won't sort by
   *
   * Performance: 2 KV writes per field (ascending + descending indexes)
   * Note: Both directions are maintained to avoid list() reverse iteration
   */
  timeFields: string[];

  /**
   * Text fields to create inverted search indexes for (full-text search)
   *
   * Use for: Short text fields (titles, names, descriptions, tags)
   * Don't use for: Very long text (>1000 chars), binary data, JSON
   *
   * Performance: N KV writes per field (N = unique tokens after stopword removal)
   * Warning: This is the most expensive index type. A 200-word field can create 100+ writes
   */
  searchFields: string[];

  /**
   * Stopwords to exclude from search tokens
   *
   * Default: Common English words ("the", "a", "is", etc.)
   * Reduces index size and improves search relevance
   */
  stopwords?: string[];

  /**
   * Maximum length for indexed field values (chars)
   *
   * Default: 1000 chars
   * Values longer than this are truncated before indexing (but stored in full)
   * Prevents excessively long index keys
   */
  maxValueLength?: number;

  /**
   * Maximum record size in bytes (JSON.stringify length)
   *
   * Default: 100 KB
   * KV max is 25 MB, but large records impact read performance
   * Recommendation: Keep under 100 KB for fast reads
   */
  maxRecordSize?: number;
}

/**
 * Base record structure - all records must include these fields
 *
 * Design Decision: We use ISO 8601 strings for timestamps instead of Unix milliseconds
 * because they're lexicographically sortable (critical for time indexes) and human-readable.
 *
 * The [key: string]: any index signature allows arbitrary fields (schema-less),
 * but TypeScript won't catch typos in field names. Consider defining specific
 * record interfaces that extend BaseRecord for type safety.
 */
export interface BaseRecord {
  /** Unique identifier (generated by server or client-provided) */
  id: string;

  /** Type name (must match a key in TYPE_CONFIGS) */
  type: string;

  /** Creation timestamp (ISO 8601) - automatically set on create */
  createdAt?: string;

  /** Last update timestamp (ISO 8601) - automatically set on create/update */
  updatedAt?: string;

  /** Allow any additional fields (schema-less design) */
  [key: string]: any;
}

/**
 * Type registry - configure each type here
 */
export const TYPE_CONFIGS: Record<string, TypeConfig> = {
  /**
   * Demo type: System Prompts
   */
  prompt: {
    indexedFields: ['category', 'isActive', 'version'],
    timeFields: ['createdAt', 'updatedAt'],
    searchFields: ['name', 'description', 'content'],
    stopwords: ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for'],
    maxValueLength: 1000,
    maxRecordSize: 100 * 1024, // 100KB
  },

  /**
   * Configuration items (key-value config storage)
   */
  config: {
    indexedFields: ['environment', 'category', 'isActive'],
    timeFields: ['createdAt', 'updatedAt'],
    searchFields: ['key', 'description'],
    maxValueLength: 500,
    maxRecordSize: 50 * 1024,
  },

  /**
   * User profiles
   */
  user: {
    indexedFields: ['email', 'role', 'status', 'department'],
    timeFields: ['createdAt', 'updatedAt', 'lastLoginAt'],
    searchFields: ['name', 'email', 'bio'],
    stopwords: ['the', 'a', 'an'],
    maxValueLength: 500,
    maxRecordSize: 50 * 1024,
  },

  /**
   * Tasks/todos
   */
  task: {
    indexedFields: ['status', 'priority', 'assignee', 'project'],
    timeFields: ['createdAt', 'updatedAt', 'dueDate', 'completedAt'],
    searchFields: ['title', 'description'],
    stopwords: ['the', 'a', 'an', 'to', 'for'],
    maxValueLength: 1000,
    maxRecordSize: 100 * 1024,
  },
};

/**
 * Get configuration for a type, with validation
 *
 * @throws Error if type doesn't exist in TYPE_CONFIGS
 * @returns TypeConfig for the specified type
 *
 * Note: This is called on every CRUD operation, so it's intentionally fast (O(1) lookup)
 */
export function getTypeConfig(type: string): TypeConfig {
  const config = TYPE_CONFIGS[type];
  if (!config) {
    throw new Error(`Unknown type: ${type}. Valid types: ${Object.keys(TYPE_CONFIGS).join(', ')}`);
  }
  return config;
}

/**
 * Validate type and ID are safe for use in KV keys
 *
 * Why we restrict characters:
 * - KV keys are limited to 512 bytes
 * - Special chars (colons, spaces) are used as delimiters in our key schema
 * - Alphanumeric + dash + underscore is safe and URL-friendly
 *
 * Why we limit length:
 * - Type + ID + prefix + field name must fit in 512 bytes
 * - Leaving room for other key components (field names, values, timestamps)
 *
 * @throws Error if validation fails
 */
export function validateTypeAndId(type: string, id: string): void {
  const safePattern = /^[a-zA-Z0-9_-]+$/;

  if (!safePattern.test(type)) {
    throw new Error(`Invalid type: ${type}. Must match [a-zA-Z0-9_-]+`);
  }

  if (!safePattern.test(id)) {
    throw new Error(`Invalid id: ${id}. Must match [a-zA-Z0-9_-]+`);
  }

  if (type.length > 50) {
    throw new Error(`Type too long: ${type.length} chars (max 50)`);
  }

  if (id.length > 200) {
    throw new Error(`ID too long: ${id.length} chars (max 200)`);
  }
}

/**
 * Generate unique ID for a new record
 *
 * Format: {timestamp}-{random}
 * Example: 1703376123456-abc123def45
 *
 * Properties:
 * - Sortable by creation time (timestamp prefix)
 * - Collision-resistant (random suffix)
 * - URL-safe (no special characters)
 * - Short enough for key constraints (~25 chars)
 *
 * Note: Not cryptographically secure. For sensitive use cases, use crypto.randomUUID()
 */
export function generateId(): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 15);
  return `${timestamp}-${random}`;
}

/**
 * Get current ISO 8601 timestamp
 *
 * Format: 2025-12-24T10:30:00.123Z
 *
 * Why ISO 8601:
 * - Lexicographically sortable (critical for time indexes)
 * - Includes milliseconds (useful for high-frequency updates)
 * - Human-readable (easier debugging)
 * - Standard format (works with Date.parse)
 *
 * @returns ISO 8601 timestamp string
 */
export function getCurrentTimestamp(): string {
  return new Date().toISOString();
}

/**
 * Default stopwords (can be overridden per type)
 */
export const DEFAULT_STOPWORDS = [
  'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at',
  'to', 'for', 'of', 'with', 'by', 'from', 'as', 'is', 'was',
  'are', 'were', 'been', 'be', 'have', 'has', 'had', 'do',
  'does', 'did', 'will', 'would', 'should', 'could', 'may',
  'might', 'must', 'can', 'this', 'that', 'these', 'those',
];
